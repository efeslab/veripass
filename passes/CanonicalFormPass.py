import pyverilog.vparser.ast as vast
from passes.common import PassBase
from passes.common import getWidthFromInt
from passes.WidthPass import WidthVisitor


class CanonicalFormPass(PassBase):
    """
    Requires the results of WidthPass
    CanonicalFormPass is responsible to transform the verilog generated by verilator to something synthesizable in quartus
    It currently handles:
    1. For partial bit selection expression, verilator could generate advanced
        verilog syntax (e.g. {a,b}[3:0] or (32'h1+b)[4:0], etc.).
        To maintain backward-compatibility, this pass walks through the pyverilator ast and instrument
        additional intermediate wires (and assigns).
    2. Guarantee the condition of the first if statement in always block matches the senslist.
        (posedge a => if (a) and negedge a => if (!a))

    """

    def __init__(self, pm, pass_state):
        # Fallback to visit_children
        super().__init__(pm, pass_state, True)
        self.width_visitor = WidthVisitor(pass_state)
    """
    Do not return anything. All code transformation is inline
    """

    def visit_ModuleDef(self, node):
        # type: (vast.Identifier, vast.Node)
        self.promoted_wires = []
        self.visit_children(node)
        instrumented_wires = []
        instrumented_assigns = []
        for identifier, val in self.promoted_wires:
            new_width = self.width_visitor.getWidth(val)
            new_wire = vast.Wire(identifier.name, getWidthFromInt(new_width))
            self.notify_new_Variable(new_wire)
            new_assign = vast.Assign(identifier, val)
            instrumented_wires.append(new_wire)
            instrumented_assigns.append(new_assign)
        node.items = instrumented_wires + node.items + instrumented_assigns

    def visit_Partselect(self, node):
        self.visit_children(node)
        if not isinstance(node.var, vast.Identifier) and not isinstance(node.var, vast.Pointer):
            need_promote = node.var
            wire_name = "parselect_promoted_{}".format(
                len(self.promoted_wires))
            promoted_var = vast.Identifier(wire_name)
            node.var = promoted_var
            self.promoted_wires.append((promoted_var, need_promote))

    def visit_Always(self, node):
        # {str(identifier name) => vast.Sens}
        sens_map = {}
        for sens in node.sens_list.list:
            if isinstance(sens.sig, vast.Identifier) and sens.type in set(['posedge', 'negedge']):
                sens_map[sens.sig.name] = sens
        first_stmt = node.statement.statements[0]
        if isinstance(first_stmt, vast.IfStatement):
            cond = first_stmt.cond
            if isinstance(cond, vast.Identifier):
                if cond.name in sens_map and sens_map[cond.name].type == 'negedge':
                    true_stmt = first_stmt.true_statement
                    false_stmt = first_stmt.false_statement
                    first_stmt.true_statement = false_stmt
                    first_stmt.false_statement = true_stmt
                    first_stmt.cond = vast.Ulnot(cond)
            elif isinstance(cond, vast.Ulnot) and isinstance(cond.right, vast.Identifier):
                cond = cond.right
                if cond.name in sens_map and sens_map[cond.name].type == 'posedge':
                    true_stmt = first_stmt.true_statement
                    false_stmt = first_stmt.false_statement
                    first_stmt.true_statement = false_stmt
                    first_stmt.false_statement = true_stmt
                    first_stmt.cond = cond
        self.visit_children(node)
